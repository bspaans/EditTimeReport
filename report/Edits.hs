module Edits ( Edit(..), Edits       -- AST
             , editsFromFile         -- parsing
             , Pred                  -- predicates
             , groupWith , fileGroup -- grouping
             , Calendar(..)          -- Data structure
             , flatten               -- Calendars
             , calendarE, CalendarE  -- Calendar of Edits
             ) where


import Char
import Maybe (mapMaybe)
import Control.Applicative
import Data.List as L (groupBy)
import qualified Data.Map as D hiding (map, filter, mapMaybe)
import System.FilePath



-- Edits — Data Structures
-- Abstract syntax for an editor log file.
--
data Edit  = Edit {   year    :: Int
                    , month   :: Int
                    , day     :: Int
                    , hour    :: Int
                    , minute  :: Int
                    , seconds :: Int
                    , dow     :: Int     -- Day of the week
                    , doy     :: Int     -- Day of the year
                    , file    :: FilePath } deriving (Show, Eq)
type Edits = [Edit]


-- Edits — Parsers
-- Parses log files generated by timechartd.py daemon
--
parseEdit     :: String   -> Maybe Edit
parseEdits    :: String   -> Edits
editsFromFile :: FilePath -> IO Edits


parseEdit s = if a then Just $ Edit y m d h mi se dw dy (unwords (drop 9 w))
                   else Nothing
                   where w = words s
                         i = take 8 w
                         a = length w >= 9 && all (all isDigit) i && w !! 8 == "EDIT"
                         (y:m:d:h:mi:se:dw:dy:[]) = map read i

parseEdits  = mapMaybe parseEdit . lines
editsFromFile f = parseEdits <$> readFile f



-- Predicates 
--
type Pred a = a -> Bool
type PredE  = Pred Edit

selEq        :: Eq b => (a -> b) -> b -> Pred a
selCombine   :: Eq a => Pred a-> Pred a -> Pred a
selCombine'  :: Eq a => Pred a -> a -> Pred a
comb         :: (a -> b -> c) -> (i -> a) -> (i -> b) -> i -> c
comb'        :: (a -> a -> c) -> (i -> a) -> i -> i -> c


selEq f a      = (==a) . f
selCombine     = comb (==)
selCombine'    = comb' (==) 
comb  op f g a = f a `op` g a
comb' op f a b = f a `op` f b


-- Edits — Grouping
-- Group edits on eg. year, month, day, file
-- 

groupWith  :: Eq a => (b -> a) -> [b] -> [[b]]
yearGroup  :: Edits -> [Edits]
monthGroup :: Edits -> [Edits]
dayGroup   :: Edits -> [Edits]
fileGroup  :: Edits -> [Edits]

groupWith y = groupBy (\f g -> y f == y g)
yearGroup   = groupWith year
monthGroup  = groupWith month
dayGroup    = groupWith day
fileGroup   = groupWith file


-- The Calendar type
--
-- The Calendar type is an abstraction over lists of days in 
-- lists of months in lists of years:
--
--      [ [ [ a ] ] ]
--              | | + years
--              | + months
--              + days  
--
newtype Calendar a = Calendar [[[a]]] deriving (Eq, Show)

instance Functor Calendar where
  fmap f (Calendar as) = Calendar (map (map (map f)) as)


-- Getting items out of the Calendar container
--
fromCalendar :: Calendar a -> [[[a]]]
flatten      :: Calendar a -> [a]

fromCalendar (Calendar as) = as
flatten = concat . concat . fromCalendar


-- Calendar of Edits
-- Using the grouping functions to build it.
-- Expects a chronological list of edits.
--
type CalendarE = Calendar Edits

calendarE :: Edits -> CalendarE
calendarE = Calendar . map (map dayGroup . monthGroup) . yearGroup 
